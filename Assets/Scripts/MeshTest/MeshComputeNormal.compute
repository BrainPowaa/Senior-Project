// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel FixupDrawArg

//////// Constants ////////

//////// Struct Data Containers ////////

struct DrawArg
{
    uint vertexCountPerInstance;
    uint instanceCount;
    uint startVertexLocation;
    uint startInstanceLocation;
};

struct Vertex
{
    // Packed number
    int position;
};

struct Triangle
{
    float3 normal;
    Vertex vertices[3];
};

//////// Buffers ////////

RWStructuredBuffer<int> ChunkDataBuffer;
AppendStructuredBuffer<Triangle> MeshBuffer;
RWStructuredBuffer<DrawArg> DrawArgsBuffer;
RWStructuredBuffer<uint> ChunkSize;

//////// Lookup Tables ////////

static const float3 NormalDirLookup[6] =
{
    float3( 1.0f,  0.0f,  0.0f),
    float3(-1.0f,  0.0f,  0.0f),
    float3( 0.0f,  1.0f,  0.0f),
    float3( 0.0f, -1.0f,  0.0f),
    float3( 0.0f,  0.0f,  1.0f),
    float3( 0.0f,  0.0f, -1.0f)
};

static const uint3 CubeFaceDirLookup[36] =
{
    // X+
    uint3(1.0f, 0.0f, 0.0f),
    uint3(1.0f, 1.0f, 0.0f),
    uint3(1.0f, 0.0f, 1.0f),

    uint3(1.0f, 1.0f, 1.0f),
    uint3(1.0f, 0.0f, 1.0f),
    uint3(1.0f, 1.0f, 0.0f),
    
    // X-
    uint3(0.0f, 0.0f, 0.0f),
    uint3(0.0f, 0.0f, 1.0f),
    uint3(0.0f, 1.0f, 0.0f),

    uint3(0.0f, 1.0f, 1.0f),
    uint3(0.0f, 1.0f, 0.0f),
    uint3(0.0f, 0.0f, 1.0f),
    
    // Y+
    uint3(0.0f, 1.0f, 0.0f),
    uint3(0.0f, 1.0f, 1.0f),
    uint3(1.0f, 1.0f, 0.0f),

    uint3(1.0f, 1.0f, 1.0f),
    uint3(1.0f, 1.0f, 0.0f),
    uint3(0.0f, 1.0f, 1.0f),
    
    // Y-
    uint3(0.0f, 0.0f, 0.0f),
    uint3(1.0f, 0.0f, 0.0f),
    uint3(0.0f, 0.0f, 1.0f),

    uint3(1.0f, 0.0f, 1.0f),
    uint3(0.0f, 0.0f, 1.0f),
    uint3(1.0f, 0.0f, 0.0f),
    
    // Z+
    uint3(0.0f, 0.0f, 1.0f),
    uint3(1.0f, 0.0f, 1.0f),
    uint3(0.0f, 1.0f, 1.0f),

    uint3(1.0f, 1.0f, 1.0f),
    uint3(0.0f, 1.0f, 1.0f),
    uint3(1.0f, 0.0f, 1.0f),
    
    // Z-
    uint3(0.0f, 0.0f, 0.0f),
    uint3(0.0f, 1.0f, 0.0f),
    uint3(1.0f, 0.0f, 0.0f),

    uint3(1.0f, 1.0f, 0.0f),
    uint3(1.0f, 0.0f, 0.0f),
    uint3(0.0f, 1.0f, 0.0f),
};

//////// Triangle Helpers ////////

// Creates a face from 2 triangles and a direction.
void CreateCubeFace(uint dir, uint3 p, float3 col)
{
    const float3 normal = NormalDirLookup[dir];
    const uint dirLookup = dir * 6;
    
    Triangle tri_a;
    
    const uint3 v1_a = CubeFaceDirLookup[dirLookup]     + p;
    const uint3 v2_a = CubeFaceDirLookup[dirLookup + 1] + p;
    const uint3 v3_a = CubeFaceDirLookup[dirLookup + 2] + p;

    tri_a.vertices[0].position = (v1_a.x & 1023) | (v1_a.y & 1023) << 10 | (v1_a.z & 1023) << 20;
    tri_a.vertices[1].position = (v2_a.x & 1023) | (v2_a.y & 1023) << 10 | (v2_a.z & 1023) << 20;
    tri_a.vertices[2].position = (v3_a.x & 1023) | (v3_a.y & 1023) << 10 | (v3_a.z & 1023) << 20;
    
    tri_a.normal = normal;
    //tri_a.color = col;

    Triangle tri_b;

    const uint3 v1_b = CubeFaceDirLookup[dirLookup + 3] + p;
    const uint3 v2_b = CubeFaceDirLookup[dirLookup + 4] + p;
    const uint3 v3_b = CubeFaceDirLookup[dirLookup + 5] + p;

    tri_b.vertices[0].position = (v1_b.x & 1023) | (v1_b.y & 1023) << 10 | (v1_b.z & 1023) << 20;
    tri_b.vertices[1].position = (v2_b.x & 1023) | (v2_b.y & 1023) << 10 | (v2_b.z & 1023) << 20;
    tri_b.vertices[2].position = (v3_b.x & 1023) | (v3_b.y & 1023) << 10 | (v3_b.z & 1023) << 20;

    tri_b.normal = normal;
    //tri_b.color = col;

    MeshBuffer.Append(tri_a);
    MeshBuffer.Append(tri_b);
}

// Main
[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const uint index = id.x + (id.z * ChunkSize[0]) + (id.y * ChunkSize[0] * ChunkSize[2]);
    
    const int voxelIso = ChunkDataBuffer[index] & 0x0F;

    if(voxelIso > 8)
    {
        const int visibilityFlag = ChunkDataBuffer[index] >> 4;

        const bool visXP = visibilityFlag & 1;
        const bool visXN = (visibilityFlag >> 1) & 1;
        const bool visYP = (visibilityFlag >> 2) & 1;
        const bool visYN = (visibilityFlag >> 3) & 1;
        const bool visZP = (visibilityFlag >> 4) & 1;
        const bool visZN = (visibilityFlag >> 5) & 1;
        
        const float3 col = 1.f;

        if(visXP)
            CreateCubeFace(0, id, col);
        
        if(visXN)
            CreateCubeFace(1, id, col);

        if(visYP)
            CreateCubeFace(2, id, col);
        
        if(visYN)
            CreateCubeFace(3, id, col);
       
        if(visZP)
            CreateCubeFace(4, id, col);
        
        if(visZN)
            CreateCubeFace(5, id, col);
    }
}

// Fixes incorrect count gathered by ComputeBuffer.CopyCount()
[numthreads(1,1,1)]
void FixupDrawArg()
{
    DrawArgsBuffer[0].vertexCountPerInstance *= 3;
}
