// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel FixupDrawArg

//////// Constants ////////

static uint3 ChunkSize = uint3(64 * 10, 64 * 1, 64 * 10);

//////// Struct Data Containers ////////

struct DrawArg
{
    uint vertexCountPerInstance;
    uint instanceCount;
    uint startVertexLocation;
    uint startInstanceLocation;
};

struct Vertex
{
    float3 position;
};

struct Triangle
{
    float3 normal;
    float3 color;
    Vertex vertices[3];
};

//////// Buffers ////////

RWStructuredBuffer<int> ChunkDataBuffer;
AppendStructuredBuffer<Triangle> MeshBuffer;
RWStructuredBuffer<DrawArg> DrawArgsBuffer;

//////// Lookup Tables ////////

static const float3 NormalDirLookup[6] =
{
    float3( 1.0f,  0.0f,  0.0f),
    float3(-1.0f,  0.0f,  0.0f),
    float3( 0.0f,  1.0f,  0.0f),
    float3( 0.0f, -1.0f,  0.0f),
    float3( 0.0f,  0.0f,  1.0f),
    float3( 0.0f,  0.0f, -1.0f)
};

static const float3 CubeFaceDirLookup[36] =
{
    // X+
    float3(1.0f, 0.0f, 0.0f),
    float3(1.0f, 1.0f, 0.0f),
    float3(1.0f, 0.0f, 1.0f),

    float3(1.0f, 1.0f, 1.0f),
    float3(1.0f, 0.0f, 1.0f),
    float3(1.0f, 1.0f, 0.0f),
    
    // X-
    float3(0.0f, 0.0f, 0.0f),
    float3(0.0f, 0.0f, 1.0f),
    float3(0.0f, 1.0f, 0.0f),

    float3(0.0f, 1.0f, 1.0f),
    float3(0.0f, 1.0f, 0.0f),
    float3(0.0f, 0.0f, 1.0f),
    
    // Y+
    float3(0.0f, 1.0f, 0.0f),
    float3(0.0f, 1.0f, 1.0f),
    float3(1.0f, 1.0f, 0.0f),

    float3(1.0f, 1.0f, 1.0f),
    float3(1.0f, 1.0f, 0.0f),
    float3(0.0f, 1.0f, 1.0f),
    
    // Y-
    float3(0.0f, 0.0f, 0.0f),
    float3(1.0f, 0.0f, 0.0f),
    float3(0.0f, 0.0f, 1.0f),

    float3(1.0f, 0.0f, 1.0f),
    float3(0.0f, 0.0f, 1.0f),
    float3(1.0f, 0.0f, 0.0f),
    
    // Z+
    float3(0.0f, 0.0f, 1.0f),
    float3(1.0f, 0.0f, 1.0f),
    float3(0.0f, 1.0f, 1.0f),

    float3(1.0f, 1.0f, 1.0f),
    float3(0.0f, 1.0f, 1.0f),
    float3(1.0f, 0.0f, 1.0f),
    
    // Z-
    float3(0.0f, 0.0f, 0.0f),
    float3(0.0f, 1.0f, 0.0f),
    float3(1.0f, 0.0f, 0.0f),

    float3(1.0f, 1.0f, 0.0f),
    float3(1.0f, 0.0f, 0.0f),
    float3(0.0f, 1.0f, 0.0f),
};

//////// Triangle Helpers ////////

// Creates a face from 2 triangles and a direction.
void CreateCubeFace(uint dir, uint3 p, float3 col)
{
    const float3 normal = NormalDirLookup[dir];
    const uint dirLookup = dir * 6;
    
    Triangle tri_a;
    
    tri_a.vertices[0].position = CubeFaceDirLookup[dirLookup]     + p,
    tri_a.vertices[1].position = CubeFaceDirLookup[dirLookup + 1] + p,
    tri_a.vertices[2].position = CubeFaceDirLookup[dirLookup + 2] + p,
    
    tri_a.normal = normal;
    tri_a.color = col;

    Triangle tri_b;

    tri_b.vertices[0].position = CubeFaceDirLookup[dirLookup + 3] + p,
    tri_b.vertices[1].position = CubeFaceDirLookup[dirLookup + 4] + p,
    tri_b.vertices[2].position = CubeFaceDirLookup[dirLookup + 5] + p,

    tri_b.normal = normal;
    tri_b.color = col;

    MeshBuffer.Append(tri_a);
    MeshBuffer.Append(tri_b);
}

// Main
[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const uint index = id.x + (id.z * ChunkSize.x) + (id.y * ChunkSize.x * ChunkSize.z);
    
    const int voxelIso = ChunkDataBuffer[index];

    if(voxelIso > 8)
    {
        const float3 col = 1.f;

        if(id.x > (ChunkSize.x-2) || ChunkDataBuffer[index + 1] <= 8)
            CreateCubeFace(0, id, col);
        
        if(id.x < 1 || ChunkDataBuffer[index - 1] <= 8)
            CreateCubeFace(1, id, col);

        if(id.y > (ChunkSize.y-2) || ChunkDataBuffer[index + ChunkSize.x * ChunkSize.z] <= 8)
            CreateCubeFace(2, id, col);
        
        if(id.y < 1 || ChunkDataBuffer[index - ChunkSize.x * ChunkSize.z] <= 8)
            CreateCubeFace(3, id, col);
       
        if(id.z > (ChunkSize.z-2) || ChunkDataBuffer[index + ChunkSize.x] <= 8)
            CreateCubeFace(4, id, col);
       
        if(id.z < 1 || ChunkDataBuffer[index - ChunkSize.x] <= 8)
            CreateCubeFace(5, id, col);
    }
}

// Fixes incorrect count gathered by ComputeBuffer.CopyCount()
[numthreads(1,1,1)]
void FixupDrawArg()
{
    DrawArgsBuffer[0].vertexCountPerInstance *= 3;
}
