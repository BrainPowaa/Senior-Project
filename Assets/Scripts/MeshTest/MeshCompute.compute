// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel FixupDrawArg

//////// Struct Data Containers ////////

struct DrawArg
{
    uint vertexCountPerInstance;
    uint instanceCount;
    uint startVertexLocation;
    uint startInstanceLocation;
};

struct Vertex
{
    float3 position;
    float3 normal;
};

struct Triangle
{
    Vertex vertices[3];
};

//////// Buffers ////////

RWStructuredBuffer<int> ChunkDataBuffer;
AppendStructuredBuffer<Triangle> MeshBuffer;
RWStructuredBuffer<DrawArg> DrawArgsBuffer;

//////// Triangle Helpers ////////

// Creates a "shaded" triangle (it just calculates the normal automatically)
Triangle CreateShadedTriangle(uint3 p1, uint3 p2, uint3 p3)
{
    float3 v1 = p2 - p1;
    float3 v2 = p3 - p1;

    float3 normal = normalize(cross(v1, v2));
    
    Triangle tri;

    tri.vertices[0].position = p1;
    tri.vertices[1].position = p2;
    tri.vertices[2].position = p3
    
    tri.vertices[0].normal = normal;
    tri.vertices[1].normal = normal;
    tri.vertices[2].normal = normal;

    return tri;
}

// Creates a face from 2 triangles and a direction.
void CreateCubeFace(uint dir, uint3 p)
{
    const Triangle tri_a = CreateShadedTriangle
    (
        float3(0.0 + p.x, 0.0 + p.y, 0.0 + p.z),
        float3(0.0 + p.x, 1.0 + p.y, 0.0 + p.z),
        float3(1.0 + p.x, 0.0 + p.y, 0.0 + p.z)
    );

    const Triangle tri_b = CreateShadedTriangle
    (
        float3(1.0 + p.x, 1.0 + p.y, 0.0 + p.z),
        float3(1.0 + p.x, 0.0 + p.y, 0.0 + p.z),
        float3(0.0 + p.x, 1.0 + p.y, 0.0 + p.z)
    );

    MeshBuffer.Append(tri_a);
    MeshBuffer.Append(tri_b);
}

// Main
[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    CreateCubeFace(0, id);
}

// Fixes incorrect count gathered by ComputeBuffer.CopyCount()
[numthreads(1,1,1)]
void FixupDrawArg()
{
    DrawArgsBuffer[0].vertexCountPerInstance *= 3;
}
